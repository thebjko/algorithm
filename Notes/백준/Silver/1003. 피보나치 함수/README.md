# [Silver III] 피보나치 함수 - 1003 

[문제 링크](https://www.acmicpc.net/problem/1003) 

# 코드 분석
## [rhzn5512 님의 코드 :](https://www.acmicpc.net/source/53069536)
```python
from sys import stdin
input = stdin.readline

t = int(input())
arr = [0] * 41
arr[0] = [1, 0]; arr[1] = [0, 1]
for i in range(2, 41):
    arr[i] = [arr[i-1][1],sum(arr[i-1])]
for i in range(t):
    N = int(input())
    print(*arr[N])
```
> 메모리 약 31 MB, 시간 32 ms

맞추고 나서 위 코드를 보고 0부터 40까지 전수 조사를 실시했다:

```txt
1 0
0 1
1 1
1 2
2 3
3 5
5 8
8 13
13 21
21 34
34 55
55 89
89 144
144 233
233 377
377 610
610 987
987 1597
1597 2584
2584 4181
4181 6765
6765 10946
10946 17711
17711 28657
28657 46368
46368 75025
75025 121393
121393 196418
196418 317811
317811 514229
514229 832040
832040 1346269
1346269 2178309
2178309 3524578
3524578 5702887
5702887 9227465
9227465 14930352
14930352 24157817
24157817 39088169
39088169 63245986
63245986 102334155
```
정말 위 코드가 구현한 규칙을 발견할 수 있었다. 하지만 답을 알기 전에 어떻게 발견할 수 있었을까?  
5에선 4, 3을 호출  
4에선 3, 2를 호출  
3에선 1, 2를 호출  
2에선 0, 1를 호출  
1에선 x  
0에선 x  

각 단계에서 호출하는 바로 아랫 단계가 몇번씩 호출하는지 계산하면 된다.  

0. 1 0
1. 0 1
2. 1 1
3. 1 2
4. 2 3
5. 3 5

그림으로 보면 더 알기 쉽다.


## 내 코드 :
```python
ls = [(1, 0), (0, 1), (1, 1)]
_, *a = map(int, open(0).read().split())
for i in range(1, max(a)):
    ls.append(tuple(i+j for i, j in zip(ls[i], ls[i+1])))
    
for i in a:
    print(*ls[i])
```
> 메모리: 31256 KB, 시간: 44 ms

